!$Id: read_restart_ncdf.F90,v 1.6 2007-11-12 13:50:17 kb Exp $
#include "cppdefs.h"
!-----------------------------------------------------------------------
!BOP
!
! !ROUTINE: Read variables from a GETM NetCDF hotstart file
!
! !INTERFACE:
   subroutine read_restart_ncdf(runtype,loop, &
                   julianday,secondsofday,tstep,hotstart_bio,llfull)
!
! !DESCRIPTION:
!  Reads from a NetCDF files (with handler ncid) opened with
!  open\_restart\_ncdf(). All variable id's are initialised. The variables
!  can be read from hotstart files with the same dimensions as given by
!  imin:imax,jmin:jmax - or - from a hotstart file with the same dimensions
!  as topo.nc (and on the same grid). This allows to use 'ncmerge' to
!  combine a number of hotstart files in to one - make a new sub-domain
!  decomposition and use the newly created hotstart file. It might be
!  necessary to use 'ncks' to cut the file to be have the same dimensions
!  as topo.nc. Allowing for the file naming scheme in GETM links for each
!  sub-domain should be made - e.g. ln -s restart.in restart.000.in; ln -s
!  restart.in restart.001.in etc.\newline
!  Halo-zones are updated using calls to update\_2d\_halo() and
!  update\_3d\_halo().
!
!  !BFM
!   - code added to initialize id's of BFM variables
!   - if subdomin netcdf-files are made with create_restart_ncdf.F90 and
!     write_restart_ncdf.F90 and  merged into complete netcdf file,
!     this version can read directly any complete netcdf file even its
!     orginates from another of files created with another sub-domain
!     composition.
!
! !USES:
   use netcdf
   use ncdf_restart
   use domain, only: iextr,jextr,ioff,joff
   use domain, only: az,au,av, kmax
   use domain, only: imin,imax,jmin,jmax,kmax
   use halo_zones, only: update_2d_halo,update_3d_halo,wait_halo
   use halo_zones, only: H_TAG,U_TAG,V_TAG
   use variables_2d
   use exceptions, only:getm_error
#ifndef NO_3D
   use variables_3d
#ifdef GETM_BIO
   use bio_var, only: numc

#endif
#endif
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer, intent(in)      :: runtype
!
! !OUTPUT PARAMETERS:
   integer, intent(out)      :: loop,julianday,secondsofday
   REALTYPE, intent(out)     :: tstep
   logical,intent(in)        :: hotstart_bio
   logical,intent(OUT)       :: llfull
!
! !DEFINED PARAMTERS:
!
! !LOCAL VARIABLES:
   integer         :: ioff_l,joff_l,ioff_0,joff_0
   integer         :: ioff_0_from_file,joff_0_from_file
   integer         :: ifill_from,jfill_from
   integer         :: iread_from,jread_from
!
! !REVISION HISTORY:
!  Original author(s): Karsten Bolding
!
!EOP
!-----------------------------------------------------------------------
!BOC
   STDERR "read_restart_ncdf_0", &
                           loop_id,julianday_id,secondsofday_id,timestep_id

   status = nf90_get_var(ncid,loop_id,loop)
   if (status .NE. NF90_NOERR) go to 10

   status = nf90_get_var(ncid,julianday_id,julianday)
   if (status .NE. NF90_NOERR) go to 10

   status = nf90_get_var(ncid,secondsofday_id,secondsofday)
   if (status .NE. NF90_NOERR) go to 10

   status = nf90_get_var(ncid,timestep_id,tstep)
   if (status .NE. NF90_NOERR) go to 10

   ioff_0_from_file=-9999
   status = nf90_inquire_attribute(ncid,NF90_GLOBAL,'joff', &
                                             xtype= joff_0_from_file)
   !new way: ioff and joff are the smallest values  of all the
   ! ioffs in the collection subdomain files.
   if (status.eq.NF90_NOERR) then
     status = nf90_get_att(ncid,NF90_GLOBAL,'ioff',ioff_0_from_file)
     if (status .NE. NF90_NOERR) go to 10

     status = nf90_get_att(ncid,NF90_GLOBAL,'joff',joff_0_from_file)
     if (status .NE. NF90_NOERR) go to 10
   else
     !old way: ioff_0 and joff_0 are the values  of the first subdomain,
     ! assuming that this subdomain is is in the colomn of the most left
     ! subdomains and in the row of the lowest (southern) subdomains.
     ioff_0_from_file=-9999
     status = nf90_inquire_attribute(ncid,NF90_GLOBAL, &
                                         'ioff_0',xtype= joff_0_from_file)
     if (status.eq.NF90_NOERR) then
       status = nf90_get_att(ncid,NF90_GLOBAL,'ioff_0',ioff_0_from_file)
       if (status .NE. NF90_NOERR) go to 10

       status = nf90_get_att(ncid,NF90_GLOBAL,'joff_0',joff_0_from_file)
       if (status .NE. NF90_NOERR) go to 10
     endif
   endif


   STDERR "read_restart_ncdf_1"

!  allows reading from subdomain or topo.nc sized files
!  i.e. ncmerged files cut to the same size as topo.nc
#ifdef __READ_HOT_HALOS_
   if (xlen .eq. ((imax+HALO)-(imin-HALO)+1) .and.  &
       ylen .eq. ((jmax+HALO)-(jmin-HALO)+1) ) then
      LEVEL3 'hotstart file(s) include HALO-zones'
      il = 1 ; ih = xlen - 2*HALO
      jl = 1 ; jh = ylen - 2*HALO
      start(1) = il + HALO
      start(2) = jl + HALO
#else
   if (xlen .eq. (imax-imin+1) .and. ylen .eq. (jmax-jmin+1) ) then
      LEVEL3 'hotstart file(s) do NOT include HALO-zones'
      il = 1 ; ih = xlen
      jl = 1 ; jh = ylen
      start(1) = il
      start(2) = jl
#endif
      iloc = 1 ; jloc = 1
      ilen = ih-il+1
      jlen = jh-jl+1
      STDERR "read_restart_ncdf: subdomain file"
      llfull=.false.
   else
      llfull=.true.
      ioff_0=(ioff-imax*(ioff/imax));joff_0=(joff-jmax*(joff/jmax))
      ioff_l=ioff-ioff_0;            joff_l=joff-joff_0
!possibility to use "old" netcdf restart files...
      if (ioff_0_from_file .eq.-9999) then
         ioff_0=0;joff_0=0
      else
!       [ij]off_0 : relative difference of position the sw-corner of the
!                          subdomain in the sw corner of the domain.
        ioff_0=ioff_0-ioff_0_from_file
        joff_0=joff_0-joff_0_from_file
      endif
!     ioff_0 < 0: filling of subdomain start at -ioff_0 ,
!                       but reading of data start from position 1
!     ioff_0 > 0: filling of subdomain start at       0 ,
!                       but reading of data start from position ioff_0
      if ( ioff_0 <= 0 ) then
         ifill_from=-ioff_0;iread_from=0
      else
         ifill_from=0; iread_from=ioff_0
      endif
      if ( joff_0 <= 0 ) then
         jfill_from=-joff_0;jread_from=0
      else
         jfill_from=0; jread_from=joff_0
      endif

! iloc: first index of array where the readed data shall be stored
! ilen: last  index of array where the readed data shall be stored
      iloc = imin;if (ioff_l.eq.0) iloc = imin+ifill_from
      jloc = jmin;if (joff_l.eq.0) jloc = jmin+jfill_from
! il:ih  array range of data  which are red from array in netcdf file
      il = max(imin+ioff_l+iread_from,1); if ( ioff_l > 0 ) il=il-ifill_from
      jl = max(jmin+joff_l+jread_from,1); if ( joff_l > 0 ) jl=jl-jfill_from
      ih = min(il+imax-iloc,xlen)
      jh = min(jl+jmax-jloc,ylen)
      ilen = ih-il+iloc
      jlen = jh-jl+jloc

      STDERR "read_restart_ncdf: fulldomain file"
      STDERR "read_restart_ncdf ioff_0_ff,joff_0_ff",ioff_0_from_file,joff_0_from_file
      STDERR "read_restart_ncdf ioff,joff",ioff,joff
      STDERR "read_restart_ncdf ioff_0,joff_0",ioff_0,joff_0
      STDERR "read_restart_ncdf ioff_l,joff_l",ioff_l,joff_l
      STDERR "read_restart_ncdf il,ih",il,ih
      STDERR "read_restart_ncdf jl,jh",jl,jh
      STDERR "read_restart_ncdf iloc,jloc",iloc,jloc
      STDERR "read_restart_ncdf ilen,jlen",ilen,jlen
      STDERR "read_restart_ncdf iread_from,jread_from",iread_from,jread_from
      STDERR "read_restart_ncdf ifill_from,jfill_from",ifill_from,jfill_from

   end if
   start(1) = il ; edges(1) = ih-il+1
   start(2) = jl ; edges(2) = jh-jl+1
   start(3) = 1  ; edges(3) = kmax+1

!  z is required
   status = &
   nf90_get_var(ncid,z_id,z(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) go to 10
   call update_2d_halo(z,z,az,imin,jmin,imax,jmax,H_TAG)
   call wait_halo(H_TAG)

   status = &
   nf90_get_var(ncid,zo_id,zo(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting zo=z"
      zo=z
   else
      call update_2d_halo(zo,zo,az,imin,jmin,imax,jmax,H_TAG)
      call wait_halo(H_TAG)
   end if

   status = &
   nf90_get_var(ncid,U_id,U(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting U=0"
      U=_ZERO_
   else
      call update_2d_halo(U,U,au,imin,jmin,imax,jmax,U_TAG)
      call wait_halo(U_TAG)
   end if

   status = &
   nf90_get_var(ncid,SlUx_id,SlUx(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting SlUx=0"
      SlUx=_ZERO_
   else
      call update_2d_halo(SlUx,SlUx,au,imin,jmin,imax,jmax,U_TAG)
      call wait_halo(U_TAG)
   end if

   status = &
   nf90_get_var(ncid,Slru_id,Slru(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting Slru=0"
   else
      call update_2d_halo(Slru,Slru,au,imin,jmin,imax,jmax,U_TAG)
      call wait_halo(U_TAG)
   end if

   status = &
   nf90_get_var(ncid,V_id,V(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting V=0"
      V=_ZERO_
   else
      call update_2d_halo(V,V,av,imin,jmin,imax,jmax,V_TAG)
      call wait_halo(V_TAG)
   end if

   status = &
   nf90_get_var(ncid,SlVx_id,SlVx(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting SlVx=0"
      SlVx=_ZERO_
   else
      call update_2d_halo(SlVx,SlVx,av,imin,jmin,imax,jmax,V_TAG)
      call wait_halo(V_TAG)
   end if

   status = &
   nf90_get_var(ncid,Slrv_id,Slrv(iloc:ilen,jloc:jlen),start,edges)
   if (status .NE. NF90_NOERR) then
      LEVEL3 "read_restart_ncdf(): setting Slrv=0"
      Slrv=_ZERO_
   else
      call update_2d_halo(Slrv,Slrv,av,imin,jmin,imax,jmax,V_TAG)
      call wait_halo(V_TAG)
   end if

#ifndef NO_3D
   if (runtype .ge. 2)  then
      status = &
      nf90_get_var(ncid,ssen_id,ssen(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting ssen=0"
         ssen=_ZERO_
      else
         call update_2d_halo(ssen,ssen,az,imin,jmin,imax,jmax,H_TAG)
         call wait_halo(H_TAG)
      end if

      status = &
      nf90_get_var(ncid,ssun_id,ssun(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting ssun=0"
         ssun=_ZERO_
         where (au .eq. 0)
            ssun=10.2
         end where
      else
         call update_2d_halo(ssun,ssun,au,imin,jmin,imax,jmax,U_TAG)
         call wait_halo(U_TAG)
      end if

      status = &
      nf90_get_var(ncid,ssvn_id,ssvn(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting ssvn=0"
         ssvn=_ZERO_
         where (av .eq. 0)
            ssvn=10.2
         end where
      else
         call update_2d_halo(ssvn,ssvn,av,imin,jmin,imax,jmax,V_TAG)
         call wait_halo(V_TAG)
      end if

      status = &
      nf90_get_var(ncid,sseo_id,sseo(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting sseo=0"
         sseo=_ZERO_
      else
         call update_2d_halo(sseo,sseo,az,imin,jmin,imax,jmax,H_TAG)
         call wait_halo(H_TAG)
      end if

      status = &
      nf90_get_var(ncid,ssuo_id,ssuo(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting ssuo=0"
         ssuo=_ZERO_
      else
         call update_2d_halo(ssuo,ssuo,au,imin,jmin,imax,jmax,U_TAG)
         call wait_halo(U_TAG)
      end if

      status = &
      nf90_get_var(ncid,ssvo_id,ssvo(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting ssvo=0"
         ssvo=_ZERO_
      else
         call update_2d_halo(ssvo,ssvo,av,imin,jmin,imax,jmax,V_TAG)
         call wait_halo(V_TAG)
      end if

      status = &
      nf90_get_var(ncid,Uinto_id,Uinto(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting Uinto=0"
         Uinto=_ZERO_
      else
         call update_2d_halo(Uinto,Uinto,au,imin,jmin,imax,jmax,U_TAG)
         call wait_halo(U_TAG)
      end if

      status = &
      nf90_get_var(ncid,Vinto_id,Vinto(iloc:ilen,jloc:jlen),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting Vinto=0"
         Vinto=_ZERO_
      else
         call update_2d_halo(Vinto,Vinto,av,imin,jmin,imax,jmax,V_TAG)
         call wait_halo(V_TAG)
      end if

      status = &
      nf90_get_var(ncid,uu_id,uu(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting uu=0"
         uu=_ZERO_
      else
         call update_3d_halo(uu,uu,au,imin,jmin,imax,jmax,kmax,U_TAG)
         call wait_halo(U_TAG)
      end if

      status = &
      nf90_get_var(ncid,vv_id,vv(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting vv=0"
         vv=_ZERO_
      else
         call update_3d_halo(vv,vv,av,imin,jmin,imax,jmax,kmax,V_TAG)
         call wait_halo(V_TAG)
      end if

      status = &
      nf90_get_var(ncid,ww_id,ww(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting ww=0"
         ww=_ZERO_
      else
         call update_3d_halo(ww,ww,az,imin,jmin,imax,jmax,kmax,H_TAG)
         call wait_halo(H_TAG)
      end if

      status = &
      nf90_get_var(ncid,uuEx_id,uuEx(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting uuEx=0"
         uuEx=_ZERO_
      else
         call update_3d_halo(uuEx,uuEx,au,imin,jmin,imax,jmax,kmax,U_TAG)
         call wait_halo(U_TAG)
      end if

      status = &
      nf90_get_var(ncid,vvEx_id,vvEx(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) then
         LEVEL3 "read_restart_ncdf(): setting vvEx=0"
         vvEx=_ZERO_
      else
         call update_3d_halo(vvEx,vvEx,av,imin,jmin,imax,jmax,kmax,V_TAG)
         call wait_halo(V_TAG)
      end if

!     tke is required
      status = &
      nf90_get_var(ncid,tke_id,tke(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) go to 10
      call update_3d_halo(tke,tke,az,imin,jmin,imax,jmax,kmax,H_TAG)
      call wait_halo(H_TAG)

!     eps is required
      status = &
      nf90_get_var(ncid,eps_id,eps(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) go to 10
      call update_3d_halo(eps,eps,az,imin,jmin,imax,jmax,kmax,H_TAG)
      call wait_halo(H_TAG)

!     num is required
      status = &
      nf90_get_var(ncid,num_id,num(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) go to 10
      call update_3d_halo(num,num,az,imin,jmin,imax,jmax,kmax,H_TAG)
      call wait_halo(H_TAG)

!     nuh is required
      status = &
      nf90_get_var(ncid,nuh_id,nuh(iloc:ilen,jloc:jlen,0:kmax),start,edges)
      if (status .NE. NF90_NOERR) go to 10
      call update_3d_halo(nuh,nuh,az,imin,jmin,imax,jmax,kmax,H_TAG)
      call wait_halo(H_TAG)

!     hn is required for adaptive coordinates
      if (hn_id .ne. -1) then
         status = &
         nf90_get_var(ncid,hn_id,hn(iloc:ilen,jloc:jlen,0:kmax),start,edges)
         if (status .NE. NF90_NOERR) go to 10
         call update_3d_halo(hn,hn,az,imin,jmin,imax,jmax,kmax,H_TAG)
         call wait_halo(H_TAG)
      endif

#ifndef NO_BAROCLINIC
      if (runtype .ge. 3)  then
!        T is required
         status = &
         nf90_get_var(ncid,T_id,T(iloc:ilen,jloc:jlen,0:kmax),start,edges)
         if (status .NE. NF90_NOERR) go to 10
         call update_3d_halo(T,T,az,imin,jmin,imax,jmax,kmax,H_TAG)
         call wait_halo(H_TAG)

!        S is required
         status = &
         nf90_get_var(ncid,S_id,S(iloc:ilen,jloc:jlen,0:kmax),start,edges)
         if (status .NE. NF90_NOERR) go to 10
         call update_3d_halo(S,S,az,imin,jmin,imax,jmax,kmax,H_TAG)
         call wait_halo(H_TAG)
      end if
#endif
#ifdef SPM
      if(spm_calc) then
        if (spm_hotstart) then
         status = &
         nf90_get_var(ncid,spm_id,spm(iloc:ilen,jloc:jlen,0:kmax),start,edges)
         if (status .NE. NF90_NOERR) then
            LEVEL3 "read_restart_ncdf(): setting spm=0"
            spm=_ZERO_
         else
            call update_3d_halo(spm,spm,az,imin,jmin,imax,jmax,kmax,H_TAG)
            call wait_halo(H_TAG)
         end if

         status = &
         nf90_get_var(ncid,spmpool_id,spm_pool(iloc:ilen,jloc:jlen),start,edges)
         if (status .NE. NF90_NOERR) then
            LEVEL3 "read_restart_ncdf(): setting spmpool=0"
            spm_pool=_ZERO_
         else
            call update_2d_halo(spm_pool,spm_pool,az,imin,jmin,imax,jmax,H_TAG)
            call wait_halo(H_TAG)
         end if
        else
         LEVEL3 'spm variables not read from hotstart file'
         LEVEL3 'set spm_init_method=0 to read them from hotstart file'
        end if

      end if
#endif

#ifdef GETM_BIO
      if( hotstart_bio ) then
#ifdef BFM_GOTM
#else
         start(4) = 1; edges(4) = numc
         status = &
         nf90_get_var(ncid,bio_id,cc3d(iloc:ilen,jloc:jlen,0:kmax,numc), &
                start,edges)
         call wait_halo(H_TAG)
         if (status .NE. NF90_NOERR) go to 10
#endif
      end if
#endif
   end if
#endif

#ifndef BFM_GOTM
        status = nf90_close(ncid)
        if (status .NE. NF90_NOERR) go to 10
#endif

   return

10 FATAL 'read_restart_ncdf: ',nf90_strerror(status)
   call getm_error("read_restart_ncdf()", "Error when reading.")
   return

   end subroutine read_restart_ncdf
!EOC

!-----------------------------------------------------------------------
! Copyright (C) 2007 - Karsten Bolding (BBH)                           !
!-----------------------------------------------------------------------
