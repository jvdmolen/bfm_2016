#include "cppdefs.h"
!-----------------------------------------------------------------------
!BOP
!
! !MODULE:  bdy_3d - 3D boundary conditions \label{bdy-3d}
!
! !INTERFACE:
   module bdy_3d
!
! !DESCRIPTION:
!
! Here, the three-dimensional boundary
! conditions for temperature and salinity are handled.
!
!  !BFM
!   code added to read boundary condition for BFM state variables
!
! !USES:
   use halo_zones, only : H_TAG,U_TAG,V_TAG
   use domain, only: imin,jmin,imax,jmax,kmax,H,az,au,av
   use domain, only: nsbv,NWB,NNB,NEB,NSB,bdy_index
   use domain, only: wi,wfj,wlj,nj,nfi,nli,ei,efj,elj,sj,sfi,sli
   use variables_3d
#ifdef _FABM_
   use getm_fabm, only: fabm_pel,fabm_ben
#endif
#ifdef BFM_GOTM
   use variables_bio_3d,only:cc3d
   use bio, only:bio_calc
   use bio_var,only:numc
#endif
   IMPLICIT NONE
!
   private
!
! !PUBLIC DATA MEMBERS:
   public init_bdy_3d, postinit_bdy_3d, do_bdy_3d
   REALTYPE, public, allocatable       :: S_bdy(:,:),T_bdy(:,:)
#ifdef _FABM_
   REALTYPE, public, allocatable       :: bio_bdy(:,:,:)
   integer, public, allocatable        :: have_bio_bdy_values(:)
#endif
#ifdef GETM_BIO
   logical,public                        :: no_gradient_ico_missing_values=.false.
   logical,public                        :: limit_all_bio=.false.
   character(len=64),public              :: area

   REALTYPE, public,dimension(:,:,:),allocatable       :: cc3d_bdy
   REALTYPE, public,dimension(:),allocatable           :: cc3d_bdy_max,cc3d_bdy_min,cc3d_bdy_multi
   integer,public,dimension(:),allocatable             :: cc3d_id
   integer,public,dimension(:),allocatable             :: cc3d_bdy_func

#endif
   logical,  public                    :: bdy3d_tmrlx=.false.
   REALTYPE, public                    :: bdy3d_tmrlx_ucut=_ONE_/50
   REALTYPE, public                    :: bdy3d_tmrlx_max=_ONE_/4
   REALTYPE, public                    :: bdy3d_tmrlx_min=_ZERO_
!
! !PRIVATE DATA MEMBERS:
   REALTYPE,         allocatable       :: bdyvertS(:), bdyvertT(:)
   REALTYPE,         allocatable       :: rlxcoef(:)
#ifdef _FABM_
   integer                             :: npel=-1,nben=-1
#endif
!
! !REVISION HISTORY:
!  Original author(s): Karsten Bolding & Hans Burchard
!
!EOP
!-----------------------------------------------------------------------

   contains

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: init_bdy_3d - initialising 3D boundary conditions
! \label{sec-init-bdy-3d}
!
! !INTERFACE:
   subroutine init_bdy_3d()
!
! !DESCRIPTION:
!
! Here, the necessary fields {\tt S\_bdy} and {\tt T\_bdy} for
! salinity and temperature, respectively, are allocated.
!
! !USES:
   IMPLICIT NONE
!
! !LOCAL VARIABLES:
   integer                   :: rc,i,j,k,n
!EOP
!-------------------------------------------------------------------------
!BOC
#ifdef DEBUG
   integer, save :: Ncall = 0
   Ncall = Ncall+1
   write(debug,*) 'init_bdy_3d() # ',Ncall
#endif

   LEVEL2 'init_bdy_3d()'
   allocate(S_bdy(0:kmax,nsbv),stat=rc)
   if (rc /= 0) stop 'init_init_bdy_3d: Error allocating memory (S_bdy)'

   allocate(T_bdy(0:kmax,nsbv),stat=rc)
   if (rc /= 0) stop 'init_init_bdy_3d: Error allocating memory (T_bdy)'

   allocate(bdyvertS(0:kmax),stat=rc)
   if (rc /= 0) stop 'init_init_bdy_3d: Error allocating memory (bdyvertS)'

   allocate(bdyvertT(0:kmax),stat=rc)
   if (rc /= 0) stop 'init_init_bdy_3d: Error allocating memory (bdyvertT)'

   allocate(rlxcoef(0:kmax),stat=rc)
   if (rc /= 0) stop 'init_init_bdy_3d: Error allocating memory (rlxcoef)'

#ifdef _FABM_
   npel=size(model%info%state_variables)
#endif

#ifdef DEBUG
   write(debug,*) 'Leaving init_bdy_3d()'
   write(debug,*)
#endif
   return
   end subroutine init_bdy_3d
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !INTERFACE:
   subroutine postinit_bdy_3d()
!
! !DESCRIPTION:
!
! Here, the necessary fields  for bfm-output are generated
! only if bio_calc is true
!
! !USES:
   IMPLICIT NONE
!
! !LOCAL VARIABLES:
   integer                   :: rc,i,j,k,n
!EOP
!-------------------------------------------------------------------------
!BOC
#ifdef BFM_GOTM
   LEVEL2 'postinit_bdy_3d() bio_calc=',bio_calc
   if ( bio_calc) then
     allocate(cc3d_bdy_max(1:numc),stat=rc)
     if (rc /= 0) stop 'init__bdy_3d: Error allocating memory (cc3d_bdy_max)'
     cc3d_bdy_max=-9999.0
     allocate(cc3d_bdy_min(1:numc),stat=rc)
     if (rc /= 0) stop 'init__bdy_3d: Error allocating memory (ccc3d_bdy_min)'
     cc3d_bdy_min=-9999.0
     allocate(cc3d_bdy_multi(1:numc),stat=rc)
     if (rc /= 0) stop 'init__bdy_3d: Error allocating memory (ccc3d_bdy_multi)'
     cc3d_bdy_multi=-9999.0
     allocate(cc3d_id(1:numc),stat=rc)
     if (rc /= 0) stop 'cc3b_bdy_3d: Error allocating memory (cc3d_id)'
     cc3d_id=-99
     allocate(cc3d_bdy_func(1:numc),stat=rc)
     if (rc /= 0) stop 'cc3b_bdy_func: Error allocating memory (cc3d_bdy_func)'
     cc3d_bdy_func=-9999
   endif
#endif
   return
   end subroutine postinit_bdy_3d
!EOC
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:  do_bdy_3d  - updating 3D boundary conditions
! \label{sec-do-bdy-3d}
!
! !INTERFACE:
   subroutine do_bdy_3d(tag,field)
!
! !DESCRIPTION:
!
! Here, the boundary conditions for salinity and temperature are
! copied to the boundary points and relaxed to the near boundary points
! by means of the flow relaxation scheme by \cite{MARTINSENea87}.
!
! As an extention to the flow relaxation scheme, it is possible
! to relax the boundary point values to the specified boundary
! condition in time, thus giving more realistic situations
! especially for outgoing flow conditions. This nudging is implemented
! to depend on the local (3D) current velocity perpendicular to
! the boundary. For strong outflow, the boundary condition is turned
! off, while for inflows it is given a high impact.
!
! !USES:
#ifdef BFM_GOTM
   use bio_var, only: numc,cc,ws
   use bfm_output, only: var_names
   use mem,only:ppN1p,ppN3n,ppN4n,ppN5s,ppZ4c
   use global_interface,only:CalcBndyConcentration,ControlNutsBdy
#endif
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer, intent(in)                 :: tag
!
! !INPUT/OUTPUT PARAMETERS:
   REALTYPE, intent(inout)             :: field(I3DFIELD)
!
! !LOCAL VARIABLES:
   integer                   :: i,j,k,l,n,ii,jj,kk,m,o,l2
   REALTYPE                  :: sp(1:4),rat
   REALTYPE                  :: bdy3d_tmrlx_umin
   REALTYPE                  :: wsum
#ifdef BFM_GOTM
   integer                   :: bio_bounds,ib,ierror
   REALTYPE                  :: S1D(1:kmax),T1D(1:kmax),R1D(1:kmax)
   logical                   :: ll
   integer                   :: bdy_on(0:kmax)   !JM added for improved control nuts bdy cnd
#endif
!EOP
!-----------------------------------------------------------------------
!BOC
#ifdef DEBUG
   integer, save :: Ncall = 0
   Ncall = Ncall+1
   write(debug,*) 'do_bdy_3d() # ',Ncall
#endif

#if 0
   select case (tag)
      case (1)
!       Lateral zero-gradient boundary condition (north & south)
         do k=1,kmax
            do i=imin,imax
               if (au(i,jmin) .eq. 3) field(i,jmin,k)=field(i,jmin+1,k)
               if (au(i,jmax) .eq. 3) field(i,jmax,k)=field(i,jmax-1,k)
            end do
         end do
      case (2)
!       Lateral zero-gradient boundary conditions (west & east)
         do k=1,kmax
            do j=jmin,jmax
               if (av(imin,j) .eq. 3) field(imin,j,k)=field(imin+1,j,k)
               if (av(imax,j) .eq. 3) field(imax,j,k)=field(imax-1,j,k)
            end do
         end do
      case default
         FATAL 'Non valid tag'
         stop 'do_bdy_3d'
   end select
#endif

#ifndef NO_BAROCLINIC
! Sponge layer factors according to Martinsen and Engedahl, 1987.
   sp(1)=_ONE_
   sp(2)=0.5625D+0
   sp(3)=0.25D+0
   sp(4)=0.0625D+0
! Hardcoding of lower limit of velocity cut-off for temporal relaxation.
! Linear variation between bdy3d_tmrlx_umin and bdy3d_tmrlx_ucut.
   bdy3d_tmrlx_umin = -_QUART_*bdy3d_tmrlx_ucut

   l = 0
   k = 0
!  STDERR "bdy_3d:NWB"
   do n=1,NWB
      l = l+1
      m = bdy_index(l)
      i = wi(n)
      do j=wfj(n),wlj(n)
         if (bdy3d_tmrlx) then
            if (au(i,j).gt.0) then
!                Local temporal relaxation coeficient depends on
!                local current just *inside* domain:
               do kk=1,kmax
                  if (uu(i,j,kk).ge.bdy3d_tmrlx_ucut) then
                     rlxcoef(kk) = bdy3d_tmrlx_max
                  else if (uu(i,j,kk).le.bdy3d_tmrlx_umin) then
                     rlxcoef(kk) = bdy3d_tmrlx_min
                  else
                     rlxcoef(kk) = (bdy3d_tmrlx_max-bdy3d_tmrlx_min)    &
                          *(uu(i,j,kk)-bdy3d_tmrlx_umin)                &
                          /(bdy3d_tmrlx_ucut-bdy3d_tmrlx_umin)          &
                          + bdy3d_tmrlx_min
                  end if
               end do
            else
               rlxcoef(:)=bdy3d_tmrlx_max
            end if
!             Temporal relaxation: Weight inner (actual) solution near boundary
!             with boundary condition (outer solution.)
            wsum= MIN(az(i-1+2,j),1)*sp(2)                              &
                 +MIN(az(i-1+3,j),1)*sp(3)                              &
                 +MIN(az(i-1+4,j),1)*sp(4)
            if (wsum>_ZERO_) then
!                Get (weighted avr of) inner near-bdy solution (sponge) cells:
               bdyvertS(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i-1+2,j),1) * sp(2) * S(i-1+2,j,:) &
                              +MIN(az(i-1+3,j),1) * sp(3) * S(i-1+3,j,:) &
                              +MIN(az(i-1+4,j),1) * sp(4) * S(i-1+4,j,:) &
                                          )
               bdyvertT(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i-1+2,j),1) * sp(2) * T(i-1+2,j,:) &
                              +MIN(az(i-1+3,j),1) * sp(3) * T(i-1+3,j,:) &
                              +MIN(az(i-1+4,j),1) * sp(4) * T(i-1+4,j,:) &
                                          )
!                Weight inner and outer (bc) solutions for use
!                in spatial relaxation/sponge
               bdyvertS(:) = (_ONE_-rlxcoef(:))*bdyvertS(:) + rlxcoef(:)*S_bdy(:,m)
               bdyvertT(:) = (_ONE_-rlxcoef(:))*bdyvertT(:) + rlxcoef(:)*T_bdy(:,m)
            else
!                No near-bdy points. Just clamp bdy temporally:
               bdyvertS(:) = S_bdy(:,m)
               bdyvertT(:) = T_bdy(:,m)
            end if
         else
!            No time-relaxation. Just clamp at bondary points.
            bdyvertS(:) = S_bdy(:,m)
            bdyvertT(:) = T_bdy(:,m)
         end if
         do ii=1,4
!           Spatial relaxation / sponge:
            if (az(i-1+ii,j).gt.0) then
               S(i-1+ii,j,:) = sp(ii)*bdyvertS(:)+(_ONE_-sp(ii))*S(i-1+ii,j,:)
               T(i-1+ii,j,:) = sp(ii)*bdyvertT(:)+(_ONE_-sp(ii))*T(i-1+ii,j,:)
#ifdef _FABM_
               if (fabm_calc) then
                  do o=1,npel
                     if (have_bio_bdy_values(o) .eq. 1) then
                        fabm_pel(i-1+ii,j,:,o) = sp(ii)*bio_bdy(:,m,o) &
                                          +(_ONE_-sp(ii))*fabm_pel(i-1+ii,j,:,o)
                     end if
                  end do
               end if
#endif
            end if
         end do
#ifdef _FABM_
!        zero gradient when we don't have bdy values
         if (fabm_calc) then
            do o=1,npel
               if (have_bio_bdy_values(o) .ne. 1) then
                  fabm_pel(i,j,:,o) = fabm_pel(i+1,j,:,o)
               end if
            end do
            fabm_ben(i,j,:) = fabm_ben(i+1,j,:)
         end if
#endif
#if BFM_GOTM
!       STDERR "start of NWB  in BFM_GOTM for",i,j
        if ( .not.bio_calc) then
         elseif ( cc3d_id(1) == -2  ) then
           forall(ib=1:numc,k=0:kmax,ii=0:3,az(ii+i,j).gt.0)
              cc3d(ii+i,j,k,ib) = sp(ii)*cc3d_bdy(ib,k,m) &
                    +(_ONE_-sp(ii))*cc3d(ii+i,j,k,ib)
           end forall
         elseif ( bio_calc) then
            bio_bounds=0
            ll=az(i,j).gt.0.and.az(i+1,j).gt.0
            ws=cc3d(i,j,:,:)
            do ib=1,numc
               !no boundaries present......
               if ( cc3d_id(ib) <-2  ) then
                 if (ll)cc3d(i,j,:,ib) = cc3d(i+1,j,:,ib)
               elseif ( cc3d_id(ib) == -1  ) then
                 if (ll .and. cc3d_bdy_max(ib).gt._ZERO_) &
                   cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                                  min(cc3d_bdy_max(ib),cc3d(i+1,j,:,ib)))
               else
                 bio_bounds=bio_bounds +1
#if 1
!JM original
                 if ( ll ) then
                     where(cc3d_bdy(bio_bounds,:,m) >= _ZERO_ )
                        cc3d(i,j,:,ib) = cc3d_bdy(bio_bounds,:,m)
                     endwhere
                     if ( cc3d_bdy_min(ib) >=_ZERO_) then
                       ! set on bounday value of adjacent point in domain
                       where(cc3d_bdy(bio_bounds,:,m) < _ZERO_ )
                        cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                                  min(cc3d_bdy_max(ib),cc3d(i+1,j,:,ib)))
                       endwhere
                     endif
                 endif
#else
!JM enhanced nuts boundary conditions calculated in new routine in BFM
                  if ( ll ) then
                    call ControlNutsBdy(cc3d(i,j,:,ib),cc3d(i+1,j,:,:), &
                     cc3d_bdy(bio_bounds,:,m), cc3d_bdy_min(ib), &
                     cc3d_bdy_max(ib),bdy_on,kmax,numc,ib, &
                     no_gradient_ico_missing_values)
                  endif
                  forall(k=0:kmax,ii=1:3,az(ii+i,j).gt.0.and.bdy_on(k).eq.1)
                    cc3d(ii+i,j,k,ib) = sp(ii)*cc3d_bdy(bio_bounds,k,m) &
                       +(_ONE_-sp(ii))*cc3d(ii+i,j,k,ib)
                  end forall
#endif
               endif
            enddo
            ll=az(i,j).gt.0.and.az(i+1,j).gt.0
            if (ll)  then
              cc(:,:)=cc3d(i,j,:,:);S1D=S(i,j,1:);T1D=T(i,j,1:);R1D=rho(i,j,1:)
              do ib=1,numc
                if ( cc3d_bdy_func(ib) .ge. 1 ) then
!                 STDERR "bdy_3d ib=",ib
                  call CalcBndyConcentration(area,'west',kmax,numc,ib, &
                  cc3d_bdy_func(ib),cc3d_bdy_multi(ib),R1D,S1D,T1D, &
                     ws(1:,:),cc(1:,:),ierror)
                  if ( ierror .eq.1) STDERR '(local) i,j,Depth=',i,j,H(i,j)
                endif
                if (limit_all_bio) then
                  if (cc3d_bdy_func(ib) >=0 ) cc(:,ib)= &
                       max(cc3d_bdy_min(ib),min(cc3d_bdy_max(ib),cc(:,ib)))
                endif
              enddo
              cc3d(i,j,:,:)=cc(:,:)
              do ib=1,numc
                if (cc3d_bdy_func(ib) >=0 ) then
                  forall(k=0:kmax,ii=1:3,az(ii+i,j).gt.0)
                      cc3d(ii+i,j,k,ib) = sp(ii)*cc(k,ib) &
                       +(_ONE_-sp(ii))*cc3d(ii+i,j,k,ib)
                  end forall
                endif
              enddo
            endif
         endif
#endif
         m = m+1
      end do
   end do

   do n = 1,NNB
      l = l+1
      m = bdy_index(l)
      j = nj(n)
      do i = nfi(n),nli(n)
         if (bdy3d_tmrlx) then
            if (av(i,j-1).gt.0) then
               do kk=1,kmax
                  if (vv(i,j-1,kk).le.-bdy3d_tmrlx_ucut) then
                     rlxcoef(kk) = bdy3d_tmrlx_max
                  else if (vv(i,j-1,kk).ge.-bdy3d_tmrlx_umin) then
                     rlxcoef(kk) = bdy3d_tmrlx_min
                  else
                     rlxcoef(kk) = -(bdy3d_tmrlx_max-bdy3d_tmrlx_min)   &
                          *(vv(i,j-1,kk)+bdy3d_tmrlx_umin)              &
                          /(bdy3d_tmrlx_ucut-bdy3d_tmrlx_umin)          &
                          + bdy3d_tmrlx_min
                  end if
               end do
            else
               rlxcoef(:)=bdy3d_tmrlx_max
            end if
            wsum= MIN(az(i,j+1-2),1)*sp(2)                              &
                 +MIN(az(i,j+1-3),1)*sp(3)                              &
                 +MIN(az(i,j+1-4),1)*sp(4)
            if (wsum>_ZERO_) then
               bdyvertS(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i,j+1-2),1) * sp(2) * S(i,j+1-2,:) &
                              +MIN(az(i,j+1-3),1) * sp(3) * S(i,j+1-3,:) &
                              +MIN(az(i,j+1-4),1) * sp(4) * S(i,j+1-4,:) &
                                          )
               bdyvertT(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i,j+1-2),1) * sp(2) * T(i,j+1-2,:) &
                              +MIN(az(i,j+1-3),1) * sp(3) * T(i,j+1-3,:) &
                              +MIN(az(i,j+1-4),1) * sp(4) * T(i,j+1-4,:) &
                                          )
               bdyvertS(:)=(_ONE_-rlxcoef(:))*bdyvertS(:)+rlxcoef(:)*S_bdy(:,m)
               bdyvertT(:)=(_ONE_-rlxcoef(:))*bdyvertT(:)+rlxcoef(:)*T_bdy(:,m)
            else
               bdyvertS(:) = S_bdy(:,m)
               bdyvertT(:) = T_bdy(:,m)
            end if
         else
            bdyvertS(:) = S_bdy(:,m)
            bdyvertT(:) = T_bdy(:,m)
         end if
         do jj=1,4
            if (az(i,j+1-jj).gt.0) then
               S(i,j+1-jj,:) = sp(jj)*bdyvertS(:)+(_ONE_-sp(jj))*S(i,j+1-jj,:)
               T(i,j+1-jj,:) = sp(jj)*bdyvertT(:)+(_ONE_-sp(jj))*T(i,j+1-jj,:)
#ifdef _FABM_
               if (fabm_calc) then
                  do o=1,npel
                     if (have_bio_bdy_values(o) .eq. 1) then
                        fabm_pel(i,j+1-jj,:,o) = sp(jj)*bio_bdy(:,m,o) &
                                         +(_ONE_-sp(jj))*fabm_pel(i,j+1-jj,:,o)
                     end if
                  end do
               end if
#endif
            end if
         end do
#ifdef _FABM_
!        zero gradient when we don't have bdy values
         if (fabm_calc) then
            do o=1,npel
               if (have_bio_bdy_values(o) .ne. 1) then
                  fabm_pel(i,j,:,o) = fabm_pel(i,j-1,:,o)
               end if
            end do
            fabm_ben(i,j,:) = fabm_ben(i,j-1,:)
         end if
#endif
#ifdef BFM_GOTM
        if ( .not.bio_calc) then
        elseif ( cc3d_id(1) == -2  ) then
           forall(ib=1:numc,k=0:kmax,jj=0:3,az(i,j-jj).gt.0)
              cc3d(i,j-jj,k,ib) = sp(jj)*cc3d_bdy(ib,k,m) &
                    +(_ONE_-sp(jj))*cc3d(i,j-jj,k,ib)
           end forall
         elseif ( bio_calc) then
            bio_bounds=0
            ll=az(i,j).gt.0.and.az(i,j-1).gt.0
            ws=cc3d(i,j,:,:)
            do ib=1,numc
               if ( cc3d_id(ib) <-2  ) then
                 if (ll) cc3d(i,j,:,ib) = cc3d(i,j-1,:,ib)
               elseif ( cc3d_id(ib) == -1  ) then
                 if (ll .and. cc3d_bdy_max(ib).gt._ZERO_) &
                   cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                           min(cc3d_bdy_max(ib),cc3d(i,j-1,:,ib)))
               else
                 bio_bounds=bio_bounds +1
#if 1
!JM original
                 if ( ll ) then
                     where(cc3d_bdy(bio_bounds,:,m) >= _ZERO_ )
                        cc3d(i,j,:,ib) = cc3d_bdy(bio_bounds,:,m)
                     endwhere
                     if ( cc3d_bdy_min(ib) >=_ZERO_) then
                       ! set on bounday value of adjacent point in domain
                       where(cc3d_bdy(bio_bounds,:,m) < _ZERO_ )
                        cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                                  min(cc3d_bdy_max(ib),cc3d(i,j-1,:,ib)))
                       endwhere
                     endif
                 endif
#else
!JM enhanced nuts boundary conditions calculated in new routine in BFM
                  if ( ll ) then
                    call ControlNutsBdy(cc3d(i,j,:,ib),cc3d(i,j-1,:,:), &
                      cc3d_bdy(bio_bounds,:,m), cc3d_bdy_min(ib), &
                      cc3d_bdy_max(ib),bdy_on,kmax,numc,ib, &
                      no_gradient_ico_missing_values)
                  endif
                  forall(k=0:kmax,jj=0:3,az(i,j-jj).gt.0.and.bdy_on(k).eq.1)
                    cc3d(i,j-jj,k,ib) = sp(jj)*cc3d_bdy(bio_bounds,k,m) &
                       +(_ONE_-sp(jj))*cc3d(i,j-jj,k,ib)
                  end forall
#endif
               endif
            enddo
            ll=az(i,j).gt.0.and.az(i,j-1).gt.0
            if (ll)  then
              cc(:,:)=cc3d(i,j,:,:);S1D=S(i,j,1:);T1D=T(i,j,1:);R1D=rho(i,j,1:)
              bio_bounds=0
              do ib=1,numc
               if ( cc3d_id(ib) >0 ) bio_bounds=bio_bounds+1
                if ( cc3d_bdy_func(ib) .ge. 1 ) then
                  call CalcBndyConcentration(area,'north',kmax,numc,ib, &
                  cc3d_bdy_func(ib),cc3d_bdy_multi(ib),R1D,S1D,T1D, &
                     ws(1:,:),cc(1:,:),ierror)
                  if ( ierror .eq.1) STDERR '(local) i,j,Depth=',i,j,H(i,j)
                endif
                if (limit_all_bio) then
                  if (cc3d_bdy_func(ib) >=0 ) cc(:,ib)= &
                       max(cc3d_bdy_min(ib),min(cc3d_bdy_max(ib),cc(:,ib)))
                endif
              enddo
              cc3d(i,j,:,:)=cc(:,:)
              bio_bounds=0
              do ib=1,numc
               if ( cc3d_id(ib) >0 ) bio_bounds=bio_bounds+1
                if (cc3d_bdy_func(ib) >=0 ) then
                  forall(k=0:kmax,jj=1:3,az(i,j-jj).gt.0)
                      cc3d(i,j-jj,k,ib) = sp(jj)*cc(k,ib) &
                       +(_ONE_-sp(jj))*cc3d(i,j-jj,k,ib)
                  end forall
                endif
              enddo
            endif

         endif
#endif
!        STDERR 'bio_3d i,j,m;',i,j,m,bio_bounds
         m = m+1
      end do
   end do

!  STDERR "bdy_3d:NEB"
   do n=1,NEB
     l = l+1
     m = bdy_index(l)
     i = ei(n)
     do j=efj(n),elj(n)
       if (bdy3d_tmrlx) then
         if (au(i-1,j).gt.0) then
           do kk=1,kmax
             if (uu(i-1,j,kk).le.-bdy3d_tmrlx_ucut) then
                     rlxcoef(kk) = bdy3d_tmrlx_max
             else if (uu(i-1,j,kk).ge.-bdy3d_tmrlx_umin) then
                     rlxcoef(kk) = bdy3d_tmrlx_min
             else
                     rlxcoef(kk) = -(bdy3d_tmrlx_max-bdy3d_tmrlx_min)   &
                          *(uu(i-1,j,kk)+bdy3d_tmrlx_umin)              &
                          /(bdy3d_tmrlx_ucut-bdy3d_tmrlx_umin)          &
                          + bdy3d_tmrlx_min
             end if
           end do
         else
           rlxcoef(:)=bdy3d_tmrlx_max
         end if
         wsum= MIN(az(i+1-2,j),1)*sp(2)                              &
                 +MIN(az(i+1-3,j),1)*sp(3)                              &
                 +MIN(az(i+1-4,j),1)*sp(4)
         if (wsum>_ZERO_) then
               bdyvertS(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i+1-2,j),1) * sp(2) * S(i+1-2,j,:) &
                              +MIN(az(i+1-3,j),1) * sp(3) * S(i+1-3,j,:) &
                              +MIN(az(i+1-4,j),1) * sp(4) * S(i+1-4,j,:) &
                                          )
               bdyvertT(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i+1-2,j),1) * sp(2) * T(i+1-2,j,:) &
                              +MIN(az(i+1-3,j),1) * sp(3) * T(i+1-3,j,:) &
                              +MIN(az(i+1-4,j),1) * sp(4) * T(i+1-4,j,:) &
                                          )
               bdyvertS(:)=(_ONE_-rlxcoef(:))*bdyvertS(:)+rlxcoef(:)*S_bdy(:,m)
               bdyvertT(:)=(_ONE_-rlxcoef(:))*bdyvertT(:)+rlxcoef(:)*T_bdy(:,m)
         else
               bdyvertS(:) = S_bdy(:,m)
               bdyvertT(:) = T_bdy(:,m)
         end if
       else
            bdyvertS(:) = S_bdy(:,m)
            bdyvertT(:) = T_bdy(:,m)
       end if
       do ii=1,4
         if (az(i+1-ii,j).gt.0) then
           S(i+1-ii,j,:) = sp(ii)*bdyvertS(:)+(_ONE_-sp(ii))*S(i+1-ii,j,:)
           T(i+1-ii,j,:) = sp(ii)*bdyvertT(:)+(_ONE_-sp(ii))*T(i+1-ii,j,:)
#ifdef _FABM_
           if (fabm_calc) then
              do o=1,npel
                if (have_bio_bdy_values(o) .eq. 1) then
                  fabm_pel(i+1-ii,j,:,o) = sp(ii)*bio_bdy(:,m,o) &
                                            +(_ONE_-sp(ii))*fabm_pel(i+1-ii,j,:,o)
                end if
              end do
           end if
#endif
         end if
       end do
#ifdef _FABM_
!        zero gradient when we don't have bdy values
       if (fabm_calc) then
            do o=1,npel
               if (have_bio_bdy_values(o) .ne. 1) then
                  fabm_pel(i,j,:,o) = fabm_pel(i-1,j,:,o)
               end if
            end do
            fabm_ben(i,j,:) = fabm_ben(i-1,j,:)
       end if
#endif
#ifdef BFM_GOTM
         if ( .not.bio_calc) then
         elseif ( cc3d_id(1) == -2  ) then
           forall(ib=1:numc,k=0:kmax,ii=0:3,az(i-ii,j).gt.0)
              cc3d(i-ii,j,k,ib) = sp(ii)*cc3d_bdy(ib,k,m) &
                    +(_ONE_-sp(ii))*cc3d(i-ii,j,k,ib)
           end forall
         elseif ( bio_calc) then
            bio_bounds=0
            ll=az(i,j).gt.0.and.az(i-1,j).gt.0
            ws=cc3d(i,j,:,:)
            do ib=1,numc
               if ( cc3d_id(ib) <-2  ) then
                 if (ll)cc3d(i,j,:,ib) = cc3d(i-1,j,:,ib)
               elseif ( cc3d_id(ib) == -1  ) then
                 if (ll .and. cc3d_bdy_max(ib).gt._ZERO_) &
                   cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                                  min(cc3d_bdy_max(ib),cc3d(i-1,j,:,ib)))
               else
                 bio_bounds=bio_bounds +1
#if 1
!JM original
                 if ( ll ) then
                     where(cc3d_bdy(bio_bounds,:,m) >= _ZERO_ )
                        cc3d(i,j,:,ib) = cc3d_bdy(bio_bounds,:,m)
                     endwhere
                     if ( cc3d_bdy_min(ib) >=_ZERO_) then
                       ! set on bounday value of adjacent point in domain
                       where(cc3d_bdy(bio_bounds,:,m) < _ZERO_ )
                        cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                                  min(cc3d_bdy_max(ib),cc3d(i-1,j,:,ib)))
                       endwhere
                     endif
                  endif

#else
!JM enhanced nuts boundary conditions calculated in new routine in BFM
                 if ( ll ) then
                   call ControlNutsBdy(cc3d(i,j,:,ib),cc3d(i-1,j,:,:),&
                     cc3d_bdy(bio_bounds,:,m),cc3d_bdy_min(ib), &
                     cc3d_bdy_max(ib), &
                     bdy_on,kmax,numc,ib, no_gradient_ico_missing_values)
                  endif
                  forall(k=0:kmax,ii=0:3,az(i-ii,j).gt.0.and.bdy_on(k).eq.1)
                    cc3d(i-ii,j,k,ib) = sp(ii)*cc3d(i,j,k,ib) &
                       +(_ONE_-sp(ii))*cc3d(i-ii,j,k,ib)
                  end forall
#endif
               endif
            enddo
            ll=az(i,j).gt.0.and.az(i-1,j).gt.0
            if (ll)  then
              cc(:,:)=cc3d(i,j,:,1:);S1D=S(i,j,1:);T1D=T(i,j,1:);R1D=rho(i,j,1:)
              do ib=1,numc
                if ( cc3d_bdy_func(ib) .ge. 1 ) then
                  call CalcBndyConcentration(area,'east',kmax,numc,ib, &
                  cc3d_bdy_func(ib),cc3d_bdy_multi(ib),R1D,S1D,T1D, &
                     ws(1:,:),cc(1:,:),ierror)
                  if ( ierror .eq.1) STDERR '(local) i,j,Depth=',i,j,H(i,j)
                endif
                if (limit_all_bio) then
                  if (cc3d_bdy_func(ib) >=0 ) cc(:,ib)= &
                       max(cc3d_bdy_min(ib),min(cc3d_bdy_max(ib),cc(:,ib)))
                endif
              enddo
              cc3d(i,j,:,:)=cc(:,:)
              do ib=1,numc
                if (cc3d_bdy_func(ib) >=0 ) then
                  forall(k=0:kmax,ii=1:3,az(i-ii,j).gt.0)
                      cc3d(i-ii,j,k,ib) = sp(ii)*cc(k,ib) &
                       +(_ONE_-sp(ii))*cc3d(i-ii,j,k,ib)
                  end forall
                endif
              enddo
            endif
         endif
#endif
         m = m+1
      end do
   end do

!  STDERR "bdy_3d:NSB"
   do n = 1,NSB
      l = l+1
      m = bdy_index(l)
      j = sj(n)
      do i = sfi(n),sli(n)
         if (av(i,j).gt.0) then
            if (bdy3d_tmrlx) then
               do kk=1,kmax
                  if (vv(i,j,kk).ge.bdy3d_tmrlx_ucut) then
                     rlxcoef(kk) = bdy3d_tmrlx_max
                  else if (vv(i,j,kk).le.bdy3d_tmrlx_umin) then
                     rlxcoef(kk) = bdy3d_tmrlx_min
                  else
                     rlxcoef(kk) = (bdy3d_tmrlx_max-bdy3d_tmrlx_min)    &
                          *(vv(i,j,kk)-bdy3d_tmrlx_umin)                &
                          /(bdy3d_tmrlx_ucut-bdy3d_tmrlx_umin)          &
                          + bdy3d_tmrlx_min
                  end if
               end do
            else
               rlxcoef(:)=bdy3d_tmrlx_max
            end if
            wsum= MIN(az(i,j-1+2),1)*sp(2)                              &
                 +MIN(az(i,j-1+3),1)*sp(3)                              &
                 +MIN(az(i,j-1+4),1)*sp(4)
            if (wsum>_ZERO_) then
               bdyvertS(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i,j-1+2),1) * sp(2) * S(i,j-1+2,:) &
                              +MIN(az(i,j-1+3),1) * sp(3) * S(i,j-1+3,:) &
                              +MIN(az(i,j-1+4),1) * sp(4) * S(i,j-1+4,:) &
                                          )
               bdyvertT(:) = (_ONE_/wsum)*(                              &
                               MIN(az(i,j-1+2),1) * sp(2) * T(i,j-1+2,:) &
                              +MIN(az(i,j-1+3),1) * sp(3) * T(i,j-1+3,:) &
                              +MIN(az(i,j-1+4),1) * sp(4) * T(i,j-1+4,:) &
                                          )
               bdyvertS(:)=(_ONE_-rlxcoef(:))*bdyvertS(:)+rlxcoef(:)*S_bdy(:,m)
               bdyvertT(:)=(_ONE_-rlxcoef(:))*bdyvertT(:)+rlxcoef(:)*T_bdy(:,m)
            else
               bdyvertS(:) = S_bdy(:,m)
               bdyvertT(:) = T_bdy(:,m)
            end if
         else
            bdyvertS(:) = S_bdy(:,m)
            bdyvertT(:) = T_bdy(:,m)
         end if
         do jj=1,4
            if (az(i,j-1+jj).gt.0) then
               S(i,j-1+jj,:) = sp(jj)*bdyvertS(:)+(_ONE_-sp(jj))*S(i,j-1+jj,:)
               T(i,j-1+jj,:) = sp(jj)*bdyvertT(:)+(_ONE_-sp(jj))*T(i,j-1+jj,:)
#ifdef _FABM_
               if (fabm_calc) then
                  do o=1,npel
                     if (have_bio_bdy_values(o) .eq. 1) then
                        fabm_pel(i,j-1+jj,:,o) = sp(jj)*bio_bdy(:,m,o) &
                                            +(_ONE_-sp(jj))*fabm_pel(i,j-1+jj,:,o)
                     end if
                  end do
               end if
#endif
            end if
         end do
#ifdef _FABM_
!        zero gradient when we don't have bdy values
         if (fabm_calc) then
            do o=1,npel
               if (have_bio_bdy_values(o) .ne. 1) then
                  fabm_pel(i,j,:,o) = fabm_pel(i,j+1,:,o)
               end if
            end do
            fabm_ben(i,j,:) = fabm_ben(i,j+1,:)
         end if
#endif
#ifdef BFM_GOTM
         if ( .not.bio_calc) then
         elseif ( cc3d_id(1) == -2  ) then
           forall(ib=1:numc,k=0:kmax,jj=0:3,az(i,jj+j).gt.0)
              cc3d(i,jj+j,k,ib) = sp(jj)*cc3d_bdy(ib,k,m) &
                    +(_ONE_-sp(jj))*cc3d(i,jj+j,k,ib)
           end forall
         elseif ( bio_calc) then
            bio_bounds=0
            ll=az(i,j).gt.0.and.az(i,j+1).gt.0
            ws=cc3d(i,j,:,:)
            do ib=1,numc
               if ( cc3d_id(ib) <-2  ) then
                 if (ll)cc3d(i,j,:,ib) = cc3d(i,j+1,:,ib)
               elseif ( cc3d_id(ib) == -1  ) then
                 if (ll .and. cc3d_bdy_max(ib).gt.0) &
                   cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                        min(cc3d_bdy_max(ib),cc3d(i,j+1,:,ib)))
               else
                 bio_bounds=bio_bounds +1
#if 1
!JM original
                 if ( ll ) then
                     where(cc3d_bdy(bio_bounds,:,m) >= _ZERO_ )
                        cc3d(i,j,:,ib) = cc3d_bdy(bio_bounds,:,m)
                     endwhere
                     if ( cc3d_bdy_min(ib) >=_ZERO_) then
                       ! set on bounday value of adjacent point in domain
                       where(cc3d_bdy(bio_bounds,:,m) < _ZERO_ )
                        cc3d(i,j,:,ib)=max(cc3d_bdy_min(ib),&
                                  min(cc3d_bdy_max(ib),cc3d(i,j+1,:,ib)))
                       endwhere
                     endif
                  endif

#else
!JM enhanced nuts boundary conditions calculated in new routine in BFM
                  if ( ll ) then
                    call ControlNutsBdy( &
                   cc3d(i,j,:,ib),cc3d(i,j+1,:,:),cc3d_bdy(bio_bounds,:,m), &
                   cc3d_bdy_min(ib),cc3d_bdy_max(ib),bdy_on,kmax,numc,ib, &
                   no_gradient_ico_missing_values)
                  endif
                  forall(k=0:kmax,jj=0:3,az(i,j+jj).gt.0.and.bdy_on(k).eq.1)
                    cc3d(i,j+jj,k,ib) = sp(jj)*cc3d_bdy(bio_bounds,k,m) &
                     +(_ONE_-sp(jj))*cc3d(i,j+jj,k,ib)
                  end forall
#endif
               endif
            enddo
            ll=az(i,j).gt.0.and.az(i,j+1).gt.0
            if (ll)  then
              cc(:,:)=cc3d(i,j,:,1:);S1D=S(i,j,1:);T1D=T(i,j,1:);R1D=rho(i,j,1:)
              do ib=1,numc
                if ( cc3d_bdy_func(ib) .ge. 1 ) then
                  call CalcBndyConcentration(area,'south',kmax,numc,ib, &
                  cc3d_bdy_func(ib),cc3d_bdy_multi(ib),R1D,S1D,T1D, &
                     ws(1:,:),cc(1:,:),ierror)
                  if ( ierror .eq.1) STDERR '(local) i,j,Depth=',i,j,H(i,j)
                endif
                if (limit_all_bio) then
                  if (cc3d_bdy_func(ib) >=0 ) cc(:,ib)= &
                       max(cc3d_bdy_min(ib),min(cc3d_bdy_max(ib),cc(:,ib)))
                endif
              enddo
              cc3d(i,j,:,:)=cc(:,:)
              do ib=1,numc
                if (cc3d_bdy_func(ib) >=0 ) then
                  forall(k=0:kmax,jj=1:3,az(i,j+jj).gt.0)
                      cc3d(i,j+jj,k,ib) = sp(jj)*cc(k,ib) &
                       +(_ONE_-sp(jj))*cc3d(i,j+jj,k,ib)
                  end forall
                endif
              enddo
            endif
         endif
#endif
         m = m+1
      end do
   end do

#ifdef _FABM_
   if ( allocated(fabm_pel) ) then
      do n=1,size(fabm_pel,4)
         call mirror_bdy_3d(fabm_pel(:,:,:,n),H_TAG)
      end do
   end if
  if ( allocated(fabm_ben) ) then
      do n=1, size(fabm_ben,3)
         call mirror_bdy_3d(fabm_ben(:,:,  n),H_TAG)
      end do
  end if
#endif
#endif

#ifdef DEBUG
   write(debug,*) 'leaving do_bdy_3d()'
   write(debug,*)
#endif
   return
   end subroutine do_bdy_3d
!EOC

!-----------------------------------------------------------------------

   end module bdy_3d

!-----------------------------------------------------------------------
! Copyright (C) 2001 - Karsten Bolding and Hans Burchard               !
!-----------------------------------------------------------------------
