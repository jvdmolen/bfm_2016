!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
! MODEL
!	   BFM - Biogeochemical Flux Model version 2.50-g
!
! MODULE
!   ModuleMem
!
! FILE
!   ModuleMem
!
! DESCRIPTION
!   Definition of Global Shared Memory
!  
!   This module contains all the structural definitions of the BFM
!   and sets up the memory layout.
!   It is automatically generated from the prototype file 
!   BFM/proto/ModuleMem.proto by including the information from 
!   BFM/General/GlobalDefsBFM.model
!   Do not directly edit this code because changes will be lost at
!   any new compilation.
!
! AUTHORS
!   Piet Ruardij & Marcello Vichi
!
! CHANGE_LOG
!   ---
!
! COPYING
!   
!   Copyright (C) 2006 P. Ruardij, the BFM team
!   (rua@nioz.nl, vichi@bo.ingv.it)
!
!   This program is free software; you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation;
!   This program is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTEABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
!
!
!
!! IMPORTANT NOTE:
!! Do not change the lines starting with two comment characters "!" 
!! These lines are used by the parser to generate the final module file

!

#include"cppdefs.h"

#include "DEBUG.h"

      module mem
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! Modules can optionally use (import) other modules
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        USE BFM_ERROR_MSG, ONLY: BFM_ERROR
        use global_mem, only:RLEN, ZERO
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! Implicit typing is never allowed
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        implicit none
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! Default all is private
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        private
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! next variable can be used to track errors.
        ! By modifying the value in bio.F90 and introduction of output statements
        ! behind an if-statement on can more easy track error by llimiting
        ! the output only for certain cases........ Example:
        !  if ( track_error ===....) write( LOGUNIT,*)............ 
        integer,public          :: track_error=0

!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
! State variables Info
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%3d-state-desc

!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%2d-state-desc

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! Definition of arrays which will hold all state variables and other
      ! global variables  used for exchange between submodels and/or output
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%3d-state-array
%2d-state-array
%3d-state-field-array surface
%3d-state-field-array bottom
%3d-state-intfield-array sinkref
%3d-diagnos-array
%2d-diagnos-array
%3_*d-diagnos-array

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! GLOBAL system CONSTANTS
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

      integer,parameter,public  ::NO_D3_BOX_STATES %3d-state-nr
      integer,parameter,public  ::NO_D2_BOX_STATES %2d-state-nr
      integer,parameter,public  ::NO_D3_BOX_DIAGNOSS %3d-diagnos-nr
      integer,parameter,public  ::NO_D2_BOX_DIAGNOSS %2d-diagnos-nr
      integer,parameter,public  ::NO_D3_BOX_DIAGNOSS%3_*d-diagnos-nr
      integer,parameter,public  ::NO_D3_BOX_FLUX %3d-calc-nr
      integer,parameter,public  ::NO_D2_BOX_FLUX %2d-calc-nr
      integer,public  ::NO_BOXES
      integer,public  ::NO_BOXES_X
      integer,public  ::NO_BOXES_Y
      integer,public  ::NO_BOXES_Z
      integer,public  ::NO_STATES
      integer,public  ::NO_BOXES_XY
      integer,public  ::NO_BOXES%3_*d-diagnos-layers
      integer,parameter,public  ::iiPel= 0
      integer,parameter,public  ::iiBen= 1000
      integer,parameter,public  ::iiReset= -1000
      integer,parameter,public  ::iiAdd= -1001
      integer,parameter,public  ::iiTotal= 0 
      integer,parameter,public  ::iiConsumption= -1 
      integer,parameter,public  ::iiProduction= 1 


      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      !! GLOBAL definition of Pelagic (D3) state variables
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%3d-state-pp

%3d-state-pointer

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      !! GLOBAL definition of Benthic (D2) state variables
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%2d-state-pp

%2d-state-pointer

%3d-Z-pointer
%3_*d-Z-pointer
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! Constituent parameters:
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%constituent

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! Group parameters:
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%3d-group-parameter

%2d-group-parameter

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      !  Global Variables
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      integer,public  :: BoxNumber
      integer,public  :: BoxNumberX
      integer,public  :: BoxNumberY
      integer,public  :: BoxNumberZ
      integer,public  :: BoxNumberXY

%1d-variable 
%1d-intvar
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
      !! GLOBAL definition of Pelagic (D3) variables which can be outputted in netcdf
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-

%3d-diagnos-desc
%3d-diaggrp-desc
%3_*d-diagnos-desc
%3d-diagnos-pp
%3d-diaggrp-pp
%3_*d-diagnos-pp
%3d-diagnos-pointer
%3d-diaggrp-pointer
%3_*d-diagnos-pointer

   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !!  GLOBAL definition of Benthic (D2) variables which can be outputted in netcdf
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%2d-diagnos-desc
%2d-diaggrp-desc
%2d-diagnos-pp
%2d-diaggrp-pp
%2d-diagnos-pointer
%2d-diaggrp-pointer

   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !  boundary fluxes
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%3d-state-field-pointer surface
%3d-state-field-pointer bottom

   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !  Other 3d-Global Variables 
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%3d-variable


   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !  Other 2d-Global Variables 
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%2d-variable
%2d-intvar
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !  variables to generate flux_output 
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           real(RLEN), public,dimension(:),allocatable ::flx_t
           integer,    public,dimension(:),allocatable ::flx_SS
           integer,    public,dimension(:),allocatable ::flx_states
           integer,    public,dimension(:),allocatable ::flx_ostates
           integer,    public,dimension(:),allocatable ::flx_calc_nr
           integer,    public,dimension(:),allocatable ::flx_CalcIn
           integer,    public,dimension(:),allocatable ::flx_option
           integer,    public                          ::flx_cal_ben_start
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !! variables to  Track a nutrient throught the model
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%track-mem
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   !! SHARED GLOBAL FUNCTIONS (must be below contains)
   !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        public flux, flux_vector, Source, Source_D3_vector, Source_D2_vector , &  
               ResetSource, ResetSource_D3_vector, ResetSource_D2_vector , &  
               fixed_quota_flux_vector,sourcesink_flux_vector, &
               sourcesink_flux, set_for_state_fluxes_zero
%3d-group-function-name
%2d-group-function-name

        contains

     !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
     !! Group Pelagic (D3) state functions
     !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%3d-groupfunctions

     !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
     !! Group Benthic (D2) state functions
     !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
%2d-groupfunctions


          !With this routine all fluxes can be resetted on zero.
          ! This routine can be used when you decide during a run to exclude 
          ! a state variable in the calulationss
          subroutine set_for_state_fluxes_zero( iiSub,iistate)
            use constants, only: RLEN, ZERO,  SEC_PER_DAY
            use global_mem, only: LOGUNIT
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ! Implicit typing is never allowed
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            implicit none

            integer,intent(IN) :: iiSub
            integer,intent(IN) :: iistate
          
            if ( iiSub== iiBen) then
              call ResetSource_D2_vector(iistate)
            else
              call ResetSource_D3_vector(iistate)
            endif
          end subroutine set_for_state_fluxes_zero

          subroutine flux_vector(iiSub,origin,destination,flux)

            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

            use constants, only: RLEN, ZERO,  SEC_PER_DAY
            use global_mem, only: LOGUNIT
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ! Implicit typing is never allowed
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            implicit none

            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            real(RLEN),intent(IN) :: flux(:)

            integer :: i
            character(len=8) :: D23

            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            !BEGIN compute
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

            TESTNANVECTOR(flux,iiSub,origin,destination)
            CHECKFLUX(-1,iiSub,origin,destination)

            if ( origin /= destination )  then
              if ( minval(flux) < ZERO) then
                D23="Pelagic"
                if ( iiSub == iiBen) D23="Benthic"
                do i=1,size(flux)
                  if (flux(i)< 0.0D+00)  then
                    write(LOGUNIT,'(''Error flux_vector: negative flux at level:'',I4)') i
                    write(LOGUNIT,'(''In '',A,'':origin='',i4,'' destination='',i4)') &
                      D23, origin,destination
                    write(LOGUNIT,'(''In '',A,'':origin='',i4,'' destination='',i4)') &
                      D23, origin,destination
                    write(LOGUNIT,'(''flux='',(G16.8))') flux(i)
                    if ( iiSub== iiBen) then
                      write(LOGUNIT,*) "state value origin:",D2STATE(i,origin)
                      write(LOGUNIT,*) "state value destination:",D2STATE(i,destination)
                    else
                      write(LOGUNIT,*) "state value origin:",D3STATE(i,origin)
                      write(LOGUNIT,*) "state value destination:",D3STATE(i,destination)
                    endif
                  endif
                enddo
                call BFM_ERROR("flux_vector","negative flux")
              endif ! minval<0
              select case ( iiSub )
                case (iiPel)
                  D3SINK(:,origin,destination)  =  flux/SEC_PER_DAY
                  D3SOURCE(:,destination,origin)=  flux/SEC_PER_DAY
                case (iiBen)
                  D2SINK(:,origin,destination) =  flux/SEC_PER_DAY
                  D2SOURCE(:,destination,origin)   = flux/SEC_PER_DAY
              end select
            else
              select case ( iiSub )
                case (iiPel)
                  where (flux > 0.0D+00 )
                    D3SOURCE(:,origin,destination) =D3SOURCE(:,origin,destination) &
                      + flux/SEC_PER_DAY
                  elsewhere
                    D3SINK(:,destination,origin) =D3SINK(:,destination,origin) - &
                      flux/SEC_PER_DAY
                  end where
                case (iiBen)
                  where (flux > 0.0D+00 )
                    D2SOURCE(:,destination,origin) =D2SOURCE(:,destination,origin) &
                      + flux/SEC_PER_DAY
                  elsewhere
                    D2SINK(:,origin,destination) =D2SINK(:,origin,destination) - &
                      flux/SEC_PER_DAY
                  end where
              end select
            endif !origin <> destination

            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            !END compute
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

            return
          end subroutine flux_vector

          subroutine testnan_vector(array,iiSub,origin,destination)
          use global_mem, only: LOGUNIT

            real(RLEN),intent(IN)    :: array(:)
            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            integer:: i=0
            do i=1,size(array)
!JM              if (isnan(array(i))== .true. ) then
              if (isnan(array(i)).eqv. .true. ) then
                write(LOGUNIT,'(''at level:'',I4)') i
                write(LOGUNIT,'(''origin='',i4,'' destination='',i4)') &
                  origin,destination
                if ( iiSub== iiBen) then
                    write(LOGUNIT,*) "state value origin:",D2STATE(i,origin)
                    write(LOGUNIT,*) "state value destination:",D2STATE(i,destination)
                else
                    write(LOGUNIT,*) "state value origin:",D3STATE(i,origin)
                    write(LOGUNIT,*) "state value destination:",D3STATE(i,destination)
                endif
                STDERR 'Nan value in flux'
                stop 1002
              endif
            enddo
          end subroutine testnan_vector

          subroutine testnan(scalar,grid_nr,iiSub,origin,destination)
          use global_mem, only: LOGUNIT

            real(RLEN),intent(IN)    :: scalar
            integer,intent(IN) :: grid_nr
            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
!JM            if (isnan(scalar)== .true. ) then
            if (isnan(scalar).eqv. .true. ) then
            write(LOGUNIT,'(''origin='',i4,'' destination='',i4)') origin,destination
            if ( iiSub == iiBen)  then
                 write(LOGUNIT,*) "state value origin:",D2STATE(grid_nr,origin)
                 write(LOGUNIT,*) "state value destination:",D2STATE(grid_nr,destination)
              else 
                 write(LOGUNIT,*) "state value origin:",D3STATE(grid_nr,origin)
                 write(LOGUNIT,*) "state value destination:",D3STATE(grid_nr,destination)
            endif
            write(LOGUNIT,*) 'Nan value in scalar flux'
            stop 1003
          endif
        end subroutine testnan
        subroutine flux(grid_nr,iiSub,origin,destination,flow,error)

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          use constants, only: RLEN, ZERO, SEC_PER_DAY
          use global_mem, only: LOGUNIT
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ! Implicit typing is never allowed
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          implicit none

          integer,intent(IN)                 :: grid_nr
          integer,intent(IN)                 :: iiSub
          integer,intent(IN)                 :: origin
          integer,intent(IN)                 :: destination
          real(RLEN),intent(IN)              :: flow
          integer,intent(INOUT),optional     :: error

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          character(len=8)    :: D23
          !BEGIN compute
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          TESTNAN(flow,grid_nr,iiSub,origin,destination)
          CHECKFLUX(grid_nr,iiSub,origin,destination)

          if ( origin /= destination ) then
            if ( flow < ZERO) then
              D23="Pelagic"
              if ( iiSub == iiBen) D23="Benthic"
              write(LOGUNIT,'(''In '',A,'':origin='',i4,'' destination='',i4)') &
                D23, origin,destination
              write(LOGUNIT,*) "Error in (scalar) vector  function: negative flux!"
              write(LOGUNIT,*) "origin,destination:", origin,destination
              write(LOGUNIT,*) flow
              if ( iiSub == iiBen)  then
                 write(LOGUNIT,*) "state value origin:",D2STATE(grid_nr,origin)
                 write(LOGUNIT,*) "state value destination:",D2STATE(grid_nr,destination)
              else 
                 write(LOGUNIT,*) "state value origin:",D3STATE(grid_nr,origin)
                 write(LOGUNIT,*) "state value destination:",D3STATE(grid_nr,destination)
              endif
              STDERR "Error in (scalar)flux function:negative flux !"
              call BFM_ERROR("flux","negative flux")
              if ( present(error)) error=1
            endif ! flow<0
            select case ( iiSub )
              case (iiPel)
                D3SINK(grid_nr,origin,destination)=  flow/SEC_PER_DAY
                D3SOURCE(grid_nr,destination,origin)= flow/SEC_PER_DAY
              case (iiBen)
                D2SINK(grid_nr,origin,destination)=  flow/SEC_PER_DAY
                D2SOURCE(grid_nr,destination,origin)= flow/SEC_PER_DAY
            end select
          else
            select case ( iiSub )
              case (iiPel)
                if (flow > 0.0 ) then
                  D3SOURCE(grid_nr,destination,origin)= D3SOURCE(grid_nr,destination,origin) &
                    +flow/SEC_PER_DAY
                else
                  D3SINK(grid_nr,origin,destination)= D3SINK(grid_nr,origin,destination) &
                    -flow/SEC_PER_DAY
                endif
              case (iiBen)
                if (flow > 0.0 ) then
                  D2SOURCE(grid_nr,destination,origin)= D2SOURCE(grid_nr,destination,origin) &
                    +flow/SEC_PER_DAY
                else
                  D2SINK(grid_nr,origin,destination)= D2SINK(grid_nr,origin,destination) &
                    -flow/SEC_PER_DAY
                endif
            end select
          endif
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          !END compute
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          return
        end subroutine flux

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! vector function to get actual rate of change in the pelagic
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        function Source_D3_vector(iistate,mode)
          use constants, only: RLEN, ZERO, SEC_PER_DAY

          implicit none

          integer, intent(IN)             ::iistate
          integer, intent(IN)             ::mode
          real(RLEN) ::Source_D3_vector(size(D3SOURCE,DIM=1))

          ! Array in sum is by sum seen as 2D-array: DIM=1 and NOT 2
          select case (mode)
            case(iiConsumption)
              Source_D3_vector=sum(D3SINK(:,iistate,:),DIM=2)*SEC_PER_DAY
            case(iiTotal)
              Source_D3_vector=(sum(D3SOURCE(:,iistate,:),DIM=2)-&
                          sum(D3SINK(:,iistate,:),DIM=2))*SEC_PER_DAY
            case(iiProduction)
              Source_D3_vector=sum(D3SOURCE(:,iistate,:),DIM=2)*SEC_PER_DAY
          end select
        end function Source_D3_vector

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! vector function to get actual rate of change in the benthic
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        function Source_D2_vector(iistate,mode)
          use constants, only: RLEN, ZERO, SEC_PER_DAY

          implicit none

          integer, intent(IN) ::iistate
          integer, intent(IN) ::mode
          real(RLEN) ::Source_D2_vector(size(D2SOURCE,DIM=1))


          ! Array in sum is by sum seen as 2D-array: DIM=1 and NOT 2
          select case (mode)
            case(iiConsumption)
              Source_D2_vector=sum(D2SINK(:,iistate,:),DIM=2)*SEC_PER_DAY
            case(iiTotal)
              Source_D2_vector=(sum(D2SOURCE(:,iistate,:),DIM=2)-&
                          sum(D2SINK(:,iistate,:),DIM=2))*SEC_PER_DAY
            case(iiProduction)
              Source_D2_vector=sum(D2SOURCE(:,iistate,:),DIM=2)*SEC_PER_DAY
          end select
        end function Source_D2_vector
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! function to get actual rate of change
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        function source(iiSub,iibox,iistate)
          use constants, only: RLEN, ZERO, SEC_PER_DAY

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ! Implicit typing is never allowed
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          implicit none

          real(RLEN)  ::Source
          integer, intent(IN)  ::iiSub
          integer, intent(IN)  ::iibox
          integer, intent(IN)  ::iistate
          if ( iiSub == iiPel )  then
            Source = (sum(D3SOURCE(iibox,iistate,:))- &
              sum(D3SINK(iibox,iistate,:)))*SEC_PER_DAY
          elseif ( iiSub == iiBen )  then
            Source = (sum(D2SOURCE(iibox,iistate,:))- &
              sum(D2SINK(iibox,iistate,:)))*SEC_PER_DAY
          endif
        end function source

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! vector to reset all rates of a state variable to zero
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        subroutine ResetSource_D3_vector(iistate)
          use constants, only: RLEN, ZERO, SEC_PER_DAY

          implicit none

          integer, intent(IN) ::iistate
          D3SOURCE(:,iistate,:)=ZERO
          D3SINK(:,iistate,:)=ZERO
        end subroutine ResetSource_D3_vector

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! vector to reset all rates of a state variable to zero
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        subroutine ResetSource_D2_vector(iistate)
          use constants, only: RLEN, ZERO, SEC_PER_DAY

          implicit none

          integer, intent(IN) ::iistate
          D2SOURCE(:,iistate,:)=ZERO
          D2SINK(:,iistate,:)=ZERO
        end subroutine ResetSource_D2_vector

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! vector to reset all rates of a state variable to zero
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        subroutine ResetSource(iiSub,iibox,iistate)
          use constants, only: RLEN, ZERO, SEC_PER_DAY

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ! Implicit typing is never allowed
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          implicit none

          integer, intent(IN)  ::iiSub
          integer, intent(IN)  ::iibox
          integer, intent(IN)  ::iistate
          if ( iiSub == iiPel )  then
            D3SOURCE(iibox,iistate,:)=ZERO
            D3SINK(iibox,iistate,:)=ZERO
          elseif ( iiSub == iiBen )  then
            D2SOURCE(iibox,iistate,:)=ZERO
            D2SINK(iibox,iistate,:)=ZERO
          endif
        end subroutine ResetSource


        subroutine unicflux(grid_nr,iiSub,origin,destination)
        use constants, only: RLEN

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          use global_mem, only: LOGUNIT
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ! Implicit typing is never allowed
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          implicit none

          integer,intent(IN)    :: grid_nr
          integer,intent(IN)    :: origin
          integer,intent(IN)    :: iiSub
          integer,intent(IN)    :: destination

          real(RLEN) :: tot
          character(len=20):: type

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          !BEGIN compute
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


          select case ( iiSub )
            case (iiPel)
              type="D3"
              if ( grid_nr <=0  ) then
                tot=sum(D3SINK(:,origin,destination))
              else
                tot=D3SINK(grid_nr,origin,destination)
              endif
            case (iiBen)
              type="D2"
              if ( grid_nr <=0  ) then
                tot=sum(D2SINK(:,origin,destination))
              else
                tot=D2SINK(grid_nr,origin,destination)
              endif
            case (iiReset)
              D3SINK(:,:,:)=0.0D+00
              D2SINK(:,:,:)=0.0D+00
              return
          end select
          if ( tot > 0.0D+00  ) then
            write(LOGUNIT,'(''Double defintion '',A2,''-flux'')')type
            write(LOGUNIT,'(''origin:'',I3,'' destination:'',I3)') origin, destination
            if ( origin /= destination ) then
              STDERR 'double definition of fluxes'
              stop 1006
            endif
          endif
        !END compute
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        return
      end subroutine unicflux

      function fixed_quota_flux_vector(mode,iiSub,which,origin, &
                                          destination,flux,collect,name_routine)

      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

      use global_mem, only: LOGUNIT
      use constants, only: RLEN
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! Implicit typing is never allowed
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      implicit none

      integer            :: fixed_quota_flux_vector
      integer,intent(IN) :: mode
      integer,intent(IN) :: iiSub
      integer,intent(IN) :: which
      integer,intent(IN) :: origin
      integer,intent(IN) :: destination
      real(RLEN),intent(IN),dimension(:) :: flux
      real(RLEN),intent(INOUT),dimension(:) :: collect
      character(len=*),optional             :: name_routine

      character(len=32)                     :: h
      real(RLEN)                            :: r

      fixed_quota_flux_vector=0
      if ( origin> 0 .and.destination >0) then
         call flux_vector(iiSub,origin, destination,flux)
      else if ( origin > 0 ) then
         call flux_vector(iiSub,origin, origin,-flux)
      elseif ( destination > 0 ) then
         call flux_vector(iiSub,destination, destination,flux)
      elseif (iiSub < 0 ) then
         if ( mode==0)  return
         if ( sum(abs(flux)/(1.0D-80+abs(collect))-1.0D+00)> 1.0D-6) then
           !Check if we have to do with small numbers
           !If this is the case do not check!
           r=abs(sum(flux)) 
           if ( r> (1.0D-80 -r+abs(sum(collect))/1.0D-6 )) then
              h=''; if ( present(name_routine)) h=' in '//name_routine
              if ( iiSub==-iiN) then
                write(LOGUNIT,'(''Warning'',A,'': N:C quotumn not fixed'')'),trim(h)
                fixed_quota_flux_vector=1
              elseif (iiSub==-iiP) then
                write(LOGUNIT,'(''Warning'',A,'': P:C quotumn not fixed'')'),trim(h)
                fixed_quota_flux_vector=1
              endif
              return
           endif
         endif
      endif      
      if ( mode==1 ) then
        if ( (which == origin) .and.(origin.ne.destination)) then
           collect=collect-flux
        else
           collect=collect+flux
        endif
      endif
      end function fixed_quota_flux_vector

      subroutine sourcesink_flux(grid_nr,iiSub,origin,destination,flow)
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ! Implicit typing is never allowed
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            implicit none

            integer,intent(IN) :: grid_nr
            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            real(RLEN),intent(IN) :: flow

            if ( destination ==0 ) then
              call flux(grid_nr,iiSub,origin,origin,-flow)
            elseif ( origin ==0 ) then
              call flux(grid_nr,iiSub,destination,destination,flow)
            else
             call  flux(grid_nr,iiSub,origin,destination,flow)
            endif
      end subroutine sourcesink_flux

      subroutine sourcesink_flux_vector(iiSub,origin,destination,flux)
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ! Implicit typing is never allowed
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            implicit none

            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            real(RLEN),intent(IN) :: flux(:)

            if ( destination ==0 ) then
              call flux_vector(iiSub,origin,origin,-flux)
            elseif ( origin ==0 ) then
              call flux_vector(iiSub,destination,destination,flux)
            else
             call  flux_vector(iiSub,origin,destination,flux)
            endif
      end subroutine sourcesink_flux_vector


      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! end of contain section
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

   end module mem

